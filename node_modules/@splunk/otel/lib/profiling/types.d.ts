import type { Resource } from '@opentelemetry/resources';
import type { ResourceFactory } from '../types';
export interface NativeProfilingOptions {
    name: string;
    samplingIntervalMicroseconds: number;
    maxSampleCutoffDelayMicroseconds?: number;
    recordDebugInfo?: boolean;
    onlyFilteredStacktraces?: boolean;
}
export interface ProfilingStacktrace {
    /** Timestamp of the sample (nanoseconds since Unix epoch). */
    timestamp: string;
    /** Formatted stacktrace. */
    stacktrace: ProfilingStackFrame[];
    traceId: Buffer;
    spanId: Buffer;
}
export interface CpuProfile {
    /** Timestamp when profiling was started (nanoseconds since Unix epoch). */
    startTimeNanos: string;
    stacktraces: ProfilingStacktrace[];
    profilerStartDuration: number;
    profilerStopDuration: number;
    profilerProcessingStepDuration: number;
}
export interface ProfilingStackFrame extends Array<string | number> {
    /** filename */
    0: string;
    /** function name */
    1: string;
    /** line number */
    2: number;
    /** column number */
    3: number;
}
export interface HeapProfileNode {
    name: string;
    scriptName: string;
    lineNumber: number;
    parentId: number;
}
export interface AllocationSample {
    nodeId: number;
    size: number;
}
export interface HeapProfile {
    samples: AllocationSample[];
    treeMap: {
        [nodeId: string]: HeapProfileNode;
    };
    timestamp: number;
    profilerCollectDuration: number;
    profilerProcessingStepDuration: number;
}
export interface ProfilingExtension {
    createCpuProfiler(options: NativeProfilingOptions): number;
    startCpuProfiler(handle: number): boolean;
    addTraceIdFilter(handle: number, traceId: string): void;
    removeTraceIdFilter(handle: number, traceId: string): void;
    start(options: NativeProfilingOptions): number;
    stop(handle: number): CpuProfile | null;
    collect(handle: number): CpuProfile | null;
    enterContext(context: unknown, traceId: string, spanId: string): void;
    exitContext(context: unknown): void;
    startMemoryProfiling(options?: MemoryProfilingOptions): void;
    stopMemoryProfiling(): void;
    collectHeapProfile(): HeapProfile | null;
}
export type ProfilingExporterFactory = (options: ProfilingOptions) => ProfilingExporter[];
export interface MemoryProfilingOptions {
    maxStackDepth?: number;
    sampleIntervalBytes?: number;
}
export interface ProfilingOptions {
    endpoint: string;
    serviceName: string;
    callstackInterval: number;
    collectionDuration: number;
    resource: Resource;
    exporterFactory: ProfilingExporterFactory;
    memoryProfilingEnabled: boolean;
    memoryProfilingOptions?: MemoryProfilingOptions;
}
export type StartProfilingOptions = Partial<Omit<ProfilingOptions, 'resource'>> & {
    resourceFactory?: ResourceFactory;
};
export interface ProfilingExporter {
    send(profile: CpuProfile): Promise<void>;
    sendHeapProfile(profile: HeapProfile): Promise<void>;
}
//# sourceMappingURL=types.d.ts.map