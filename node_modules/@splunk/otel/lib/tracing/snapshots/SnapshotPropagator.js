"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotPropagator = exports.VOLUME_BAGGAGE_KEY = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
exports.VOLUME_BAGGAGE_KEY = 'splunk.trace.snapshot.volume';
function withVolumeBaggage(context, isSelected) {
    let baggage = api_1.propagation.getBaggage(context);
    const entry = { value: isSelected ? 'highest' : 'off' };
    if (baggage === undefined) {
        baggage = api_1.propagation.createBaggage({
            [exports.VOLUME_BAGGAGE_KEY]: entry,
        });
    }
    else {
        baggage = baggage.setEntry(exports.VOLUME_BAGGAGE_KEY, entry);
    }
    return api_1.propagation.setBaggage(context, baggage);
}
function normalizeRate(rate) {
    return Math.min(1.0, Math.max(rate, 0.0));
}
class SnapshotPropagator {
    constructor(selectionRate) {
        this.selectionRate = normalizeRate(selectionRate);
        this.sampler = new sdk_trace_base_1.TraceIdRatioBasedSampler(this.selectionRate);
    }
    inject(_context, _carrier, _setter) { }
    extract(context, _carrier, _getter) {
        var _a;
        const baggage = api_1.propagation.getBaggage(context);
        if (baggage === undefined) {
            return this.attachVolumeBaggage(context);
        }
        const volumeFromBaggage = (_a = baggage.getEntry(exports.VOLUME_BAGGAGE_KEY)) === null || _a === void 0 ? void 0 : _a.value;
        if (volumeFromBaggage === 'highest' || volumeFromBaggage === 'off') {
            return context;
        }
        return this.attachVolumeBaggage(context);
    }
    fields() {
        return [];
    }
    attachVolumeBaggage(context) {
        const span = api_1.trace.getSpan(context);
        if (span === undefined) {
            // We have no trace ID, so we can't use TraceIdRatioBasedSampler.
            const isSelected = Math.random() < this.selectionRate;
            return withVolumeBaggage(context, isSelected);
        }
        const decision = this.sampler.shouldSample(context, span.spanContext().traceId).decision;
        return withVolumeBaggage(context, decision === sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED);
    }
}
exports.SnapshotPropagator = SnapshotPropagator;
//# sourceMappingURL=SnapshotPropagator.js.map