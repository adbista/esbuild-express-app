"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop = exports.start = void 0;
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const utils_1 = require("./utils");
const metrics_1 = require("./metrics");
const profiling_1 = require("./profiling");
const tracing_1 = require("./tracing");
const instrumentations_1 = require("./instrumentations");
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const logging_1 = require("./logging");
const resource_1 = require("./resource");
const Snapshots_1 = require("./tracing/snapshots/Snapshots");
const running = {
    metrics: null,
    profiling: null,
    tracing: null,
    logging: null,
};
function isSignalEnabled(option, envVar, def) {
    var _a;
    return (_a = option !== null && option !== void 0 ? option : (0, utils_1.parseEnvBooleanString)((0, utils_1.getNonEmptyEnvVar)(envVar))) !== null && _a !== void 0 ? _a : def;
}
const start = (options = {}) => {
    if (running.logging ||
        running.metrics ||
        running.profiling ||
        running.tracing) {
        throw new Error('Splunk APM already started');
    }
    const logLevel = options.logLevel
        ? (0, utils_1.toDiagLogLevel)(options.logLevel)
        : (0, utils_1.parseLogLevel)((0, utils_1.getNonEmptyEnvVar)('OTEL_LOG_LEVEL'));
    if (logLevel !== api_1.DiagLogLevel.NONE) {
        api_1.diag.setLogger(new api_1.DiagConsoleLogger(), logLevel);
    }
    const envResource = (0, resource_1.getDetectedResource)();
    const serviceName = options.serviceName ||
        (0, utils_1.getNonEmptyEnvVar)('OTEL_SERVICE_NAME') ||
        envResource.attributes[semantic_conventions_1.ATTR_SERVICE_NAME];
    if (!serviceName) {
        api_1.diag.warn('service.name attribute is not set, your service is unnamed and will be difficult to identify. ' +
            'Set your service name using the OTEL_RESOURCE_ATTRIBUTES environment variable. ' +
            'E.g. OTEL_RESOURCE_ATTRIBUTES="service.name=<YOUR_SERVICE_NAME_HERE>"');
    }
    const { tracingOptions, loggingOptions, profilingOptions, metricsOptions } = (0, instrumentations_1.parseOptionsAndConfigureInstrumentations)(options);
    let metricsEnabledByDefault = false;
    if (isSignalEnabled(options.profiling, 'SPLUNK_PROFILER_ENABLED', false)) {
        running.profiling = (0, profiling_1.startProfiling)(profilingOptions);
        if (profilingOptions.memoryProfilingEnabled) {
            metricsEnabledByDefault = true;
        }
    }
    if ((0, Snapshots_1.isSnapshotProfilingEnabled)()) {
        (0, Snapshots_1.startSnapshotProfiling)({
            endpoint: profilingOptions.endpoint,
            serviceName: profilingOptions.serviceName,
            resource: profilingOptions.resource,
        });
    }
    if (isSignalEnabled(options.tracing, 'SPLUNK_TRACING_ENABLED', true)) {
        running.tracing = (0, tracing_1.startTracing)(tracingOptions);
    }
    if (isSignalEnabled(options.logging, 'SPLUNK_AUTOMATIC_LOG_COLLECTION', false)) {
        running.logging = (0, logging_1.startLogging)(loggingOptions);
    }
    if (isSignalEnabled(options.metrics, 'SPLUNK_METRICS_ENABLED', metricsEnabledByDefault)) {
        running.metrics = (0, metrics_1.startMetrics)(metricsOptions);
    }
    const meterProvider = (0, utils_1.getEnvBoolean)('SPLUNK_INSTRUMENTATION_METRICS_ENABLED', false)
        ? api_1.metrics.getMeterProvider()
        : createNoopMeterProvider();
    for (const instrumentation of (0, tracing_1.getLoadedInstrumentations)()) {
        instrumentation.setMeterProvider(meterProvider);
    }
};
exports.start = start;
function createNoopMeterProvider() {
    const meter = (0, api_1.createNoopMeter)();
    return {
        getMeter(_name, _version, _options) {
            return meter;
        },
        // AWS Lambda instrumentation check for the existence of forceFlush,
        // if it does not exist, an error is logged for each span.
        forceFlush() {
            return Promise.resolve();
        },
    };
}
const stop = async () => {
    const promises = [];
    if (running.logging) {
        promises.push(running.logging.stop());
        running.logging = null;
    }
    if (running.metrics) {
        promises.push(running.metrics.stop());
        running.metrics = null;
    }
    if (running.tracing) {
        promises.push((0, tracing_1.stopTracing)());
        running.tracing = null;
    }
    if (running.profiling) {
        promises.push(promises.push(running.profiling.stop()));
        running.profiling = null;
    }
    return Promise.all(promises);
};
exports.stop = stop;
//# sourceMappingURL=start.js.map